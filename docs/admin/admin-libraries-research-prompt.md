# Промпт для ИИ-исследователя: подбор библиотек для Admin Web App (GitHub Pages)

Вы — исследователь и архитектор фронтенда. Ваша задача: предложить и обосновать набор библиотек для отдельного Admin Web App (SPA) под GitHub Pages. Приложение управляет и мониторит киоски (Android-устройство киоска), подключено к локальному агенту и/или удалённому админ-сервису, агрегирует логи и события, группирует всё по сессиям.

Контекст проекта:

- Клиентская часть киоска уже реализована. Админ-приложение — отдельный репозиторий/папка, независимая поставка (статический хостинг GitHub Pages).
- Бэкенд (локальный агент киоска) — Node.js/TypeScript, порт по умолчанию 7070, REST API для статусов/OBD/толщиномера/платежей, в будущем — админ-сервис (HTTP API + SSE/WebSocket для потоковых событий). Допускается CORS.
- Требование: наблюдаемость (сессии, события, метрики), разграничение доступа (роль «Admin»), стабильность и прозрачность.

Ограничения платформы:

- Хостинг — GitHub Pages (статическая выдача). Нельзя выполнять серверный код. Взаимодействие с агентом/сервисом — через HTTP(S)/SSE/WebSocket.
- Нужна корректная работа SPA с basepath (например, /admin/). Нужна 404-страница, перенаправляющая на `index.html` (SPA fallback).
- Быстрый билд (Vite). Строгий TypeScript, ESLint, Prettier.

Функциональные требования Admin Web App:

1) Аутентификация/авторизация администратора (JWT/Access Token) и хранение токена безопасно (in-memory + refresh, без LocalStorage для чувствительных данных; cookie httpOnly допускается, если домены позволяют).

2) Навигация: Dashboard, Сессии (список/фильтры/поиск), Детали сессии (шаги, события, логи), Устройства (OBD/толщиномер/замки), Платежи (интенты/статусы), Мониторинг (графики, метрики), Настройки (env-конфиг, интеграции, фичи).

3) Работа с данными:
   - Запросы к API (REST) + потоковые события (SSE/WebSocket) для live-логов/статусов.
   - Кэширование запросов, автоматический рефетч, экспоненциальный бэкофф при ошибках сети.
   - Типобезопасность договоров API (zod/io-ts/ts-rest/openapi-typescript — выбрать подход и обосновать).

4) Компоненты UI уровня «админки»:
   - Таблицы (виртуализация, серверная пагинация, фильтры) — нужна мощная таблица.
   - Формы (валидация/схемы) для конфигов и фильтров.
   - Графики (метрики, количество событий, задержки, частота ошибок).
   - Нотификации/тосты, модалки подтверждений, копирование токенов, кодовые блоки.

5) Наблюдаемость фронтенда:
   - Трассировка (OpenTelemetry Web SDK) и/или Sentry (ошибки, performance), экспорт в совместимый бэкенд.

6) Интернационализация (ru затем en), даты/временные зоны.

7) Деплой на GitHub Pages (Actions), роутер с basepath, переменные окружения.

Выходные данные исследования (структурировано):

1) Архитектурная нота: стек приложения (фреймворк, маршрутизация, сборка, язык).

2) Категории библиотек и рекомендации (по каждой — 2–3 альтернативы с анализом, затем «итоговый выбор»):
   - Фреймворк UI (React/Vue/Svelte)
   - Маршрутизация (React Router / TanStack Router / Vue Router)
   - Клиент данных (Axios/fetch + TanStack Query/RTK Query/SWR)
   - Типобезопасные схемы API (zod/io-ts/ts-rest/openapi-клиент)
   - Таблицы (AG Grid Community / TanStack Table / MUI Data Grid)
   - Графики (Apache ECharts / Recharts / Chart.js)
   - Формы (React Hook Form / Formik) + валидатор (zod/yup)
   - Компонентная библиотека (MUI / Ant Design / Chakra UI) + иконки (Tabler Icons/Material Icons)
   - Тосты/уведомления (notistack/sonner/react-hot-toast)
   - i18n (i18next/formatjs)
   - Даты (date-fns/dayjs/luxon)
   - SSE/WebSocket клиент (eventsource-polyfill/native EventSource / socket.io-client/plain ws)
   - Наблюдаемость (Sentry / OpenTelemetry Web SDK + OTLP exporter)
   - Управление состоянием (Zustand/Redux Toolkit) — минимально, в дополнение к query-клиенту
   - PWA (опционально)
3) Для «итогового выбора» — привести для каждого:
   - Название, версия (рекомендуемая на сегодня), лицензия, краткое назначение
   - Почему выбран (ключевые критерии и компромиссы)
   - Ссылки: документация, GitHub, релизы
   - Установка (npm/pnpm), ссылка на CDN (если уместно)
   - Минимальный пример использования (код, 10–30 строк)
   - Риски и миграция (если проект вырастет)
4) Блок «Совместимость и производительность»:
   - Целевые браузеры (Chrome Android/Win/macOS), полифилы при необходимости
   - Размер бандла и как его контролировать (код-сплиттинг, динамические импорты)
   - Стратегии кэширования запросов, дедупликация и retry
5) Безопасность и конфигурация:
   - Хранение токенов доступа, защита от XSS/CSRF в контексте статического хостинга
   - Конфигурация окружения на рантайме (config.json) vs на билд-тайме (Vite env)
6) План внедрения:
   - Список npm пакетов с командами установки
   - Шаблон минимального Vite-проекта (React+TS) со списком файлов и ключевых настроек (tsconfig, eslint, prettier, vite, router base)
   - GitHub Actions для публикации на Pages, настройка 404/SPA fallback

Формат ответа:

- Чётко структурированный markdown без эмодзи.
- Таблицы там, где удобно сравнивать.
- Кодовые блоки — минимальные и релевантные.
- Краткие выводы после каждой категории и финальная сводка.
