# Stage 1 — Архитектурный макет (2025-10-13)

## Целевая архитектура компонентов

| Слой | Компонент | Технологии | Ответственность | Источник артефактов |
| --- | --- | --- | --- | --- |
| Презентация | Android-приложение `apps-unified/android-kiosk` | Kotlin, AndroidX, WebView, Jetpack Navigation (план) | UI сценарии толщиномера и диагностики, управление состоянием, выдача инструкций клиенту | Базовый модуль WebView; макеты из WinForms (`блок 4`) и Android-примеров (`блок 6`) |
| Оркестрация | Kotlin слой (UseCase/Repository) | Coroutines, ViewModel, Hilt (план) | Управление жизненным циклом сеанса, маршрутизация запросов к JNI/Python, управление платежным UX | Собственный код, опыт `apps/kiosk-agent` (логика сеансов) |
| Нативный мост | JNI слой | Android NDK, CMake | Типобезопасный мост между Kotlin и C++ API, сериализация структур | Новые заголовки в `libs/cpp/include` |
| Драйверы устройств | C++ ядро | C++20, Serial/CAN API, J2534 адаптация | Управление адаптерами OBD-II/толщиномера, поток данных в общий формат, watchdog | Исходники из `блок 3`, `блок 4`, `блок 6`, `блок 5` (serialport-rs как референс) |
| Аналитика | Python-пакеты | Python 3.11 embedded, FastAPI (опция), Pandas-lite | Интерпретация DTC, расчёт толщиномера, генерация отчётов | Скрипты `блок 1`, будущие модули `libs/python` |
| Хранилище и отчёты | SQLite (on-device), PDF renderer | Jetpack Room (Kotlin), wkhtmltopdf или аналог | Сохранение сессий, отчётов, очередь отправки на email | Опыт `apps/kiosk-agent` (reports/storage) |
| Коммуникации | IPC между Kotlin ↔ Python | gRPC over UNIX socket / in-process API | Передача результатов диагностики, триггеры генерации отчётов | Разрабатываемый адаптер |
| Телеметрия и обновления | Kotlin service + C++ hooks | Android WorkManager, встроенный updater | Логирование, бэкапы, обновления модулей | Документы `docs/tech/update-security-*` |

## Жизненный цикл диагностики (OBD-II)

1. UI инициирует сессию и запрашивает подтверждение клиента.
2. Kotlin UseCase создаёт контекст диагностики, резервирует устройство, открывает канал JNI.
3. JNI вызывает C++ API `ObdSession::start`, который настраивает J2534/ELM327 драйвер, применяет протокол.
4. Полученные кадры преобразуются в стандартные структуры (`ObdFrame`, `DtcEntry`) и передаются обратно через JNI.
5. Kotlin слой собирает данные и пробрасывает их в Python-аналитику через IPC (JSON или protobuf на сокете).
6. Python модуль выполняет расшифровку DTC, применяет эвристику, формирует отчёт и возвращает агрегированный результат.
7. UI отображает статус сканирования, после завершения предлагает оплату и показывает отчёт.
8. Хранилище сохраняет сеанс, запускается отправка отчёта клиенту, система освобождает адаптер.

Аналогичный поток для толщиномера: драйвер C++ использует BLE/Serial API, Python анализирует матрицу замеров и возвращает итоговые показатели.

## Размещение Python

- **Основной режим:** встраиваем интерпретатор Python в приложение (Chaquopy или Python-Android-template) и поставляем модули `libs/python/packages`. Это гарантирует оффлайн работу и предсказуемые зависимости.
- **Тяжёлые задачи:** допускается вспомогательный локальный сервис (FastAPI + Uvicorn) в отдельном процессе, общение через UNIX-сокет. Запуск инициируется Kotlin слоем только по необходимости; по умолчанию аналитика выполняется in-process.
- **Валидация:** для обоих режимов поддерживается единый API (protobuf). При выборе режима в конфигурации учитывается объём памяти и требования к отклику.

## Потоки данных после отказа от Node.js

- **Диагностика OBD-II:** `UI → Kotlin → JNI → C++ driver → Python → Kotlin → UI/report → SQLite`.
- **Толщиномер:** `UI → Kotlin → JNI → C++ driver (BLE) → Python → Kotlin → UI/report → SQLite`.
- **Платежи:** Kotlin интеграция с PSP SDK, результаты сохраняются локально и связываются с сессией, отчёты обновляются через Python слой только для подписи.
- **Мониторинг:** события из Kotlin отправляются в локальный журнал (structured logs); опционально выгружаются наружу через VPN (Firezone) согласно политикам безопасности.

## Выбор базовых проектов

- **Android UI:** используем `apps-unified/android-kiosk` как основу. Проекты `блок 2` и `блок 6` сохраняются как справочные примеры подключения Bluetooth/Serial, но не попадают в итоговую сборку.
- **WinForms:** `блок 4` служит главным источником для J2534 логики и UI сценариев. `блок 3` — вспомогательный пример лёгкого клиента.

## Следующие шаги

1. Спроектировать API нативного слоя (`libs/cpp/include/obd_session.h`, `thickness_session.h`, `report_bridge.h`).
2. Определить схему сериализации данных Kotlin ↔ Python (protobuf схемы для DTC, thickness).
3. Подготовить диаграммы последовательностей (PlantUML) для OBD и толщиномера на основе описанного цикла.
4. Оценить требования к ресурсам (RAM, CPU) для встраиваемого Python и подобрать оптимальный дистрибутив.
