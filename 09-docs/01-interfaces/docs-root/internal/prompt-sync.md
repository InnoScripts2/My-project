# Интеграция и синхронизация: Supabase, ключи, офлайн, Bluetooth/OBD-II (универсальный промпт)

Этот промпт описывает полный сценарий синхронизации проекта: настройка Supabase, управление API-ключами и секретами, деплой Edge Function, а также требования к Bluetooth-стеку и адаптивной работе с OBD-II адаптерами (не только ELM327), с поддержкой 12V автомобилей (особый фокус: Toyota и Lexus), запросы разрешений на устройстве, офлайн-режим и малый размер приложения.

## Цели

- Надёжная связка фронтенда/агента/облака с Supabase.
- Безопасное хранение ключей и секретов (в .env, вне репозитория).
- Развёрнутый payments webhook (HMAC) + запись в БД.
- Адаптивная Bluetooth-интеграция с поддержкой разных OBD-II адаптеров.
- Офлайн-работа UI без внешнего URL/сервера.
- Минимальный размер приложений.

## Настройка Supabase

1. Создать проект в Supabase и получить:
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY` (для фронтенда с RLS)
   - `SUPABASE_SERVICE_ROLE_KEY` (только серверные компоненты)
2. Инициализировать CLI в локальной среде:
   - `supabase login`
   - `supabase link --project-ref <project-ref>`
3. Применить миграции:
   - `supabase db query < db/migrations/001_create_webhook_events_and_rpc.sql`
4. Развернуть Edge Function `payments-webhook`:
   - `supabase functions deploy payments-webhook --project-ref <project-ref> --no-verify-jwt`
5. Задать переменные функции (Dashboard → Edge Functions → payments-webhook → Settings):
   - `PROVIDER_WEBHOOK_SECRET`
   - `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY` доступны среде автоматически.
6. Настроить провайдера платежей на URL функции: `https://<project>.functions.supabase.co/payments-webhook` с заголовком `x-provider-signature` (HMAC SHA-256 от сырого тела).

## Хранение ключей и секретов

- Все ключи и секrets хранить в локальном `.env` (см. `.env.example`).
- `.env` и `.env.*` игнорируются Git, `.env.example` содержит только структуру.
- Ключи:
  - `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`, `PROVIDER_WEBHOOK_SECRET`.
  - `AGENT_API_BASE` — базовый URL агента (для фронтенда), может переопределяться `?agent=`.
- Не коммитить реальные значения, распространять только через защищённые каналы.

## API ключи: создание и запись

- Supabase:
  - ANON/SERVICE-ROLE выдаются в Project Settings → API. Скопируйте в `.env`.
- Платёжный провайдер:
  - Секрет вебхука `PROVIDER_WEBHOOK_SECRET` сгенерировать у провайдера и записать в `.env` и в переменные функции.
- Дополнительные интеграции по мере появления — по той же схеме: `.env`/Dashboard.

## Bluetooth/OBD-II: требования и реализация

- Цели:
  - Поддержка множества адаптеров: ELM327-совместимые (Bluetooth Classic/Serial), BLE-адаптеры с открытым GATT, потенциально USB-Serial.
  - Адаптация к 12V системам — корректная инициализация, устойчивость к просадкам питания.
  - Особый фокус: Toyota и Lexus — предустановленные профили и протоколы (ISO 15765-4 CAN, ISO 9141-2/KWP2000 при необходимости), выбор приоритета протокола и таймаутов.
- Архитектура (см. `apps/kiosk-agent`):
  - Все подключения через `ObdConnectionManager` и `connectOptions` (валидация входных параметров).
  - Транспорты: Bluetooth Classic (RFCOMM), BLE (если открыт GATT профиль), Serial (COM) — модульная абстракция.
  - Инициализация ELM-подобных: `ATZ`, `ATE0`, выбор протокола (`ATSP0` авто или принудительно для Toyota/Lexus), таймауты, проверка `ELM327 vX`.
  - Чтение DTC, PID, MIL, Freeze Frame, self-check; операция Clear DTC с логированием и подтверждением.
  - Расширяемые декодеры DTC на базе открытых источников.
- Аппаратные разрешения и UX:
  - На Android запрашивать разрешения Bluetooth/Location при старте, чётко объяснить клиенту.
  - В Web/Electron — использовать соответствующие API (Web Bluetooth, Node serial/bluetooth) в DEV; в PROD — через локальный агент.
  - Показывать статусы: «Поиск адаптера», «Подключение», «Инициализация», «Готово/Ошибка»; ретраи с экспоненциальной задержкой.
- Совместимость:
  - Не ограничиваться LM327: поддерживать ELM327-совместимых и документированные BLE адаптеры. Для закрытых протоколов — интеграция только через официальный SDK/док.

## Разрешения на устройстве (Android)

- WebView-приложение должно:
  - Иметь `uses-permission` для `BLUETOOTH`, `BLUETOOTH_ADMIN`, `BLUETOOTH_CONNECT`, `BLUETOOTH_SCAN` (API 31+), `ACCESS_FINE_LOCATION` (для scan), `INTERNET`.
  - Запрашивать runtime permissions с понятным диалогом перед началом поиска устройств.
  - Обрабатывать отказ/повторный запрос, вести журнал.

## Офлайн-работа и малый размер

- Фронтенд: один `index.html` + минимальные ассеты; `service-worker.js` для кэширования офлайн.
- Android WebView:
  - Встроить `offline.html` и JS-bridge для ограниченного сценария, когда URL недоступен.
  - Быстрый HEAD-пробинг перед загрузкой, graceful fallback на `offline.html`.
- Агент: запускаться локально без обязательного подключения к интернету, накапливать события локально (SQLite) и отправлять при появлении сети.
- Размер: избегать тяжёлых зависимостей, использовать нативные API и легковесные утилиты; шрифты/иконки — только строго необходимые.

## Конфигурация AGENT_API_BASE

- По умолчанию фронтенд использует `protocol://host:apiPort`.
- Можно задать `?agent=http://<HOST:PORT>` — сохранится в `localStorage.AGENT_API_BASE`.
- Сброс: `?clearAgent=1`.

## Проверки и метрики

- Логи агента без персональных данных; отдельные логи действий с замком/устройствами.
- Метрики Prometheus по платежам и подключению устройств.
- Авто-сброс сессий по таймауту бездействия.

## Критерии приёмки

- Миграции применяются без ошибок, функция деплоится, тестовый HMAC запрос возвращает 200 и фиксируется в `webhook_events`.
- Фронтенд общается с агентом по настраиваемому адресу, статусы устройств обновляются.
- Bluetooth-подключение устойчиво: ретраи, выбор протокола, чтение/сброс DTC.
- Android запрашивает разрешения и корректно ведёт себя при отказе.
- Приложение работает офлайн (кэш/`offline.html`), не ломая основной поток.
